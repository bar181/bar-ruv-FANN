I've identified and fixed the bugs in the factorial function. Here's the corrected version with explanations:

## Bugs Found:

1. **Bug 1**: `result = 0` - This should be `1` because factorial is a product operation. Starting with 0 means any multiplication will always result in 0.

2. **Bug 2**: `range(1, n)` - This excludes `n` itself. For factorial, we need to multiply all numbers from 1 to n inclusive, so it should be `range(1, n+1)`.

3. **Bug 3** (not mentioned but important): The function doesn't handle the special case of `factorial(0)`, which by definition equals 1.

## Fixed Code:

```python
def factorial(n):
    """Calculate factorial of n (n!)"""
    if n < 0:
        return "Error: Negative number"
    
    # Special case: 0! = 1
    if n == 0:
        return 1
    
    result = 1  # Bug fix 1: Start with 1, not 0
    for i in range(1, n + 1):  # Bug fix 2: Include n in the range
        result *= i
    
    return result

# Original test cases (now passing):
assert factorial(0) == 1  # Now returns 1
assert factorial(5) == 120  # Now returns 120
assert factorial(1) == 1  # Now returns 1

# Additional test cases:
assert factorial(3) == 6  # 3! = 3 × 2 × 1 = 6
assert factorial(7) == 5040  # 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040
assert factorial(10) == 3628800  # 10! = 3,628,800

# Edge case testing:
assert factorial(-5) == "Error: Negative number"  # Negative input
assert factorial(0) == 1  # Zero factorial

print("All tests passed!")
```

## Explanation of Fixes:

1. **Changed initial value from 0 to 1**: Since factorial is the product of numbers, we must start with 1 (the multiplicative identity). Starting with 0 would make every factorial equal to 0.

2. **Fixed range to include n**: The original `range(1, n)` would calculate (n-1)! instead of n!. For example, `factorial(5)` would only multiply 1×2×3×4, missing the 5.

3. **Added special case for 0**: By mathematical definition, 0! = 1. This is a special case that needs to be handled explicitly.

The function now correctly calculates factorials for all non-negative integers and properly handles the error case for negative numbers.