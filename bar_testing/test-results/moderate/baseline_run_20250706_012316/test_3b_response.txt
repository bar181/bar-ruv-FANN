```python
class Matrix:
    """
    2D Matrix with basic operations.
    
    This class provides fundamental matrix operations without using NumPy,
    including transpose, multiplication, and determinant calculation.
    """
    
    def __init__(self, data):
        """
        Initialize a Matrix from a 2D list.
        
        Args:
            data: A 2D list representing the matrix. Must be non-empty
                  and all rows must have the same length.
        
        Raises:
            ValueError: If data is empty or rows have different lengths.
            TypeError: If data is not a list of lists.
        
        Example:
            >>> m = Matrix([[1, 2], [3, 4]])
            >>> print(m)
            Matrix([[1, 2], [3, 4]])
        """
        if not isinstance(data, list):
            raise TypeError("Matrix data must be a list")
        
        if not data:
            raise ValueError("Matrix cannot be empty")
        
        if not all(isinstance(row, list) for row in data):
            raise TypeError("Matrix data must be a list of lists")
        
        if not all(row for row in data):
            raise ValueError("Matrix rows cannot be empty")
        
        # Check that all rows have the same length
        row_length = len(data[0])
        if not all(len(row) == row_length for row in data):
            raise ValueError("All matrix rows must have the same length")
        
        # Create a deep copy to avoid external modifications
        self.data = [row[:] for row in data]
        self.rows = len(data)
        self.cols = len(data[0])
    
    def __str__(self):
        """Return string representation of the matrix."""
        return f"Matrix({self.data})"
    
    def __repr__(self):
        """Return detailed string representation."""
        return self.__str__()
    
    def __eq__(self, other):
        """Check if two matrices are equal."""
        if not isinstance(other, Matrix):
            return False
        return self.data == other.data
    
    def __getitem__(self, indices):
        """Get matrix element at position [i, j]."""
        i, j = indices
        return self.data[i][j]
    
    def __setitem__(self, indices, value):
        """Set matrix element at position [i, j]."""
        i, j = indices
        self.data[i][j] = value
    
    def transpose(self):
        """
        Return the transpose of the matrix.
        
        Returns:
            Matrix: A new matrix that is the transpose of this matrix.
        
        Example:
            >>> m = Matrix([[1, 2, 3], [4, 5, 6]])
            >>> m_t = m.transpose()
            >>> print(m_t)
            Matrix([[1, 4], [2, 5], [3, 6]])
        """
        # Create transposed data using list comprehension
        transposed_data = [[self.data[i][j] for i in range(self.rows)] 
                          for j in range(self.cols)]
        return Matrix(transposed_data)
    
    def multiply(self, other):
        """
        Perform matrix multiplication (self @ other).
        
        Args:
            other: Another Matrix to multiply with.
        
        Returns:
            Matrix: The result of matrix multiplication.
        
        Raises:
            TypeError: If other is not a Matrix.
            ValueError: If dimensions are incompatible for multiplication.
        
        Example:
            >>> m1 = Matrix([[1, 2], [3, 4]])
            >>> m2 = Matrix([[5, 6], [7, 8]])
            >>> result = m1.multiply(m2)
            >>> print(result)
            Matrix([[19, 22], [43, 50]])
        """
        if not isinstance(other, Matrix):
            raise TypeError("Can only multiply with another Matrix")
        
        if self.cols != other.rows:
            raise ValueError(
                f"Cannot multiply {self.rows}x{self.cols} matrix "
                f"with {other.rows}x{other.cols} matrix"
            )
        
        # Initialize result matrix with zeros
        result = [[0 for _ in range(other.cols)] for _ in range(self.rows)]
        
        # Perform matrix multiplication
        for i in range(self.rows):
            for j in range(other.cols):
                for k in range(self.cols):
                    result[i][j] += self.data[i][k] * other.data[k][j]
        
        return Matrix(result)
    
    def _minor(self, row, col):
        """
        Calculate the minor matrix by removing specified row and column.
        
        Args:
            row: Row index to remove.
            col: Column index to remove.
        
        Returns:
            Matrix: The minor matrix.
        """
        minor_data = []
        for i in range(self.rows):
            if i == row:
                continue
            minor_row = []
            for j in range(self.cols):
                if j == col:
                    continue
                minor_row.append(self.data[i][j])
            minor_data.append(minor_row)
        
        return Matrix(minor_data)
    
    def determinant(self):
        """
        Calculate the determinant of the matrix using recursive cofactor expansion.
        
        Returns:
            float: The determinant value.
        
        Raises:
            ValueError: If the matrix is not square.
        
        Example:
            >>> m = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            >>> det = m.determinant()
            >>> print(det)
            0
        """
        if self.rows != self.cols:
            raise ValueError("Determinant is only defined for square matrices")
        
        # Base case: 1x1 matrix
        if self.rows == 1:
            return self.data[0][0]
        
        # Base case: 2x2 matrix
        if self.rows == 2:
            return (self.data[0][0] * self.data[1][1] - 
                   self.data[0][1] * self.data[1][0])
        
        # Recursive case: use cofactor expansion along first row
        det = 0
        for j in range(self.cols):
            # Calculate cofactor
            sign = (-1) ** j
            minor = self._minor(0, j)
            cofactor = sign * minor.determinant()
            det += self.data[0][j] * cofactor
        
        return det
    
    def is_invertible(self):
        """
        Check if the matrix can be inverted.
        
        A matrix is invertible if and only if it is square and 
        its determinant is non-zero.
        
        Returns:
            bool: True if the matrix is invertible, False otherwise.
        
        Example:
            >>> m1 = Matrix([[1, 2], [3, 4]])
            >>> print(m1.is_invertible())
            True
            >>> m2 = Matrix([[1, 2], [2, 4]])
            >>> print(m2.is_invertible())
            False
        """
        if self.rows != self.cols:
            return False
        
        try:
            det = self.determinant()
            # Use a small epsilon for floating-point comparison
            epsilon = 1e-10
            return abs(det) > epsilon
        except Exception:
            return False
    
    def add(self, other):
        """
        Add two matrices element-wise.
        
        Args:
            other: Another Matrix to add.
        
        Returns:
            Matrix: The sum of the two matrices.
        
        Raises:
            TypeError: If other is not a Matrix.
            ValueError: If matrices have different dimensions.
        """
        if not isinstance(other, Matrix):
            raise TypeError("Can only add another Matrix")
        
        if self.rows != other.rows or self.cols != other.cols:
            raise ValueError("Matrices must have the same dimensions for addition")
        
        result = [[self.data[i][j] + other.data[i][j] 
                  for j in range(self.cols)] 
                  for i in range(self.rows)]
        
        return Matrix(result)
    
    def scalar_multiply(self, scalar):
        """
        Multiply the matrix by a scalar value.
        
        Args:
            scalar: A numeric value to multiply by.
        
        Returns:
            Matrix: A new matrix with all elements multiplied by the scalar.
        """
        result = [[self.data[i][j] * scalar 
                  for j in range(self.cols)] 
                  for i in range(self.rows)]
        
        return Matrix(result)
    
    def to_list(self):
        """Return a deep copy of the matrix data as a 2D list."""
        return [row[:] for row in self.data]


# Usage Examples
def usage_examples():
    """Demonstrate various matrix operations."""
    print("=== Matrix Operations Examples ===\n")
    
    # Example 1: Basic operations
    print("1. Basic Matrix Creation and Access:")
    m1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    print(f"Matrix m1: {m1}")
    print(f"Element at [1, 2]: {m1[1, 2]}")
    print(f"Dimensions: {m1.rows}x{m1.cols}\n")
    
    # Example 2: Transpose
    print("2. Matrix Transpose:")
    m2 = Matrix([[1, 2], [3, 4], [5, 6]])
    print(f"Original: {m2}")
    print(f"Transposed: {m2.transpose()}\n")
    
    # Example 3: Multiplication
    print("3. Matrix Multiplication:")
    m3 = Matrix([[1, 2], [3, 4]])
    m4 = Matrix([[5, 6], [7, 8]])
    print(f"m3: {m3}")
    print(f"m4: {m4}")
    print(f"m3 × m4: {m3.multiply(m4)}\n")
    
    # Example 4: Determinant
    print("4. Determinant Calculation:")
    m5 = Matrix([[2, 1, 3], [1, 0, 1], [1, 2, 1]])
    print(f"Matrix: {m5}")
    print(f"Determinant: {m5.determinant()}\n")
    
    # Example 5: Invertibility check
    print("5. Invertibility Check:")
    m6 = Matrix([[1, 2], [3, 4]])
    m7 = Matrix([[1, 2], [2, 4]])
    print(f"m6 = {m6}, is invertible: {m6.is_invertible()}")
    print(f"m7 = {m7}, is invertible: {m7.is_invertible()}\n")
    
    # Example 6: Matrix addition and scalar multiplication
    print("6. Addition and Scalar Multiplication:")
    m8 = Matrix([[1, 2], [3, 4]])
    m9 = Matrix([[5, 6], [7, 8]])
    print(f"m8 + m9: {m8.add(m9)}")
    print(f"m8 × 2: {m8.scalar_multiply(2)}")


# Comprehensive Unit Tests
import unittest

class TestMatrix(unittest.TestCase):
    """Comprehensive unit tests for Matrix class."""
    
    def test_initialization(self):
        """Test matrix initialization and validation."""
        # Valid initialization
        m = Matrix([[1, 2], [3, 4]])
        self.assertEqual(m.rows, 2)
        self.assertEqual(m.cols, 2)
        
        # Empty matrix
        with self.assertRaises(ValueError):
            Matrix([])
        
        # Inconsistent row lengths
        with self.assertRaises(ValueError):
            Matrix([[1, 2], [3, 4, 5]])
        
        # Non-list input
        with self.assertRaises(TypeError):
            Matrix("not a list")
        
        # Not a list of lists
        with self.assertRaises(TypeError):
            Matrix([1, 2, 3])
    
    def test_transpose(self):
        """Test matrix transpose operation."""
        # Square matrix
        m1 = Matrix([[1, 2], [3, 4]])
        m1_t = m1.transpose()
        self.assertEqual(m1_t.to_list(), [[1, 3], [2, 4]])
        
        # Rectangular matrix
        m2 = Matrix([[1, 2, 3], [4, 5, 6]])
        m2_t = m2.transpose()
        self.assertEqual(m2_t.to_list(), [[1, 4], [2, 5], [3, 6]])
        
        # 1x1 matrix
        m3 = Matrix([[5]])
        m3_t = m3.transpose()
        self.assertEqual(m3_t.to_list(), [[5]])
    
    def test_multiply(self):
        """Test matrix multiplication."""
        # Square matrices
        m1 = Matrix([[1, 2], [3, 4]])
        m2 = Matrix([[5, 6], [7, 8]])
        result = m1.multiply(m2)
        self.assertEqual(result.to_list(), [[19, 22], [43, 50]])
        
        # Rectangular matrices
        m3 = Matrix([[1, 2, 3], [4, 5, 6]])
        m4 = Matrix([[7, 8], [9, 10], [11, 12]])
        result2 = m3.multiply(m4)
        self.assertEqual(result2.to_list(), [[58, 64], [139, 154]])
        
        # Incompatible dimensions
        with self.assertRaises(ValueError):
            m1.multiply(m3)
        
        # Non-matrix multiplication
        with self.assertRaises(TypeError):
            m1.multiply([[1, 2], [3, 4]])
    
    def test_determinant(self):
        """Test determinant calculation."""
        # 1x1 matrix
        m1 = Matrix([[5]])
        self.assertEqual(m1.determinant(), 5)
        
        # 2x2 matrix
        m2 = Matrix([[1, 2], [3, 4]])
        self.assertEqual(m2.determinant(), -2)
        
        # 3x3 matrix
        m3 = Matrix([[2, 1, 3], [1, 0, 1], [1, 2, 1]])
        self.assertEqual(m3.determinant(), -2)
        
        # Singular matrix (det = 0)
        m4 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        self.assertEqual(m4.determinant(), 0)
        
        # Non-square matrix
        m5 = Matrix([[1, 2, 3], [4, 5, 6]])
        with self.assertRaises(ValueError):
            m5.determinant()
    
    def test_is_invertible(self):
        """Test invertibility check."""
        # Invertible matrix
        m1 = Matrix([[1, 2], [3, 4]])
        self.assertTrue(m1.is_invertible())
        
        # Singular matrix
        m2 = Matrix([[1, 2], [2, 4]])
        self.assertFalse(m2.is_invertible())
        
        # Non-square matrix
        m3 = Matrix([[1, 2, 3], [4, 5, 6]])
        self.assertFalse(m3.is_invertible())
    
    def test_edge_cases(self):
        """Test edge cases and special matrices."""
        # Identity matrix
        identity = Matrix([[1, 0], [0, 1]])
        self.assertEqual(identity.determinant(), 1)
        self.assertTrue(identity.is_invertible())
        
        # Zero matrix
        zero = Matrix([[0, 0], [0, 0]])
        self.assertEqual(zero.determinant(), 0)
        self.assertFalse(zero.is_invertible())
        
        # Large values
        large = Matrix([[1e10, 2e10], [3e10, 4e10]])
        self.assertAlmostEqual(large.determinant(), -2e20)
    
    def test_additional_operations(self):
        """Test addition and scalar multiplication."""
        m1 = Matrix([[1, 2], [3, 4]])
        m2 = Matrix([[5, 6], [7, 8]])
        
        # Addition
        sum_matrix = m1.add(m2)
        self.assertEqual(sum_matrix.to_list(), [[6, 8], [10, 12]])
        
        # Scalar multiplication
        scaled = m1.scalar_multiply(3)
        self.assertEqual(scaled.to_list(), [[3, 6], [9, 12]])
        
        # Addition with incompatible dimensions
        m3 = Matrix([[1, 2, 3]])
        with self.assertRaises(ValueError):
            m1.add(m3)


if __name__ == "__main__":
    # Run usage examples
    usage_examples()
    
    # Run unit tests
    print("\n=== Running Unit Tests ===")
    unittest.main(argv=[''], exit=False, verbosity=2)
```