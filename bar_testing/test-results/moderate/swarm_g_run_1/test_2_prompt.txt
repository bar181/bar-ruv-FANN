Debug and fix the following Python code that manages a shared counter with multiple threads:

```python
import threading
import time

class SharedCounter:
    def __init__(self):
        self.count = 0
        self.lock = threading.Lock()
    
    def increment(self, times=1000):
        for _ in range(times):
            # Bug 1: Not using the lock
            temp = self.count
            time.sleep(0.00001)  # Simulate some work
            self.count = temp + 1
    
    def get_count(self):
        # Bug 2: Not thread-safe read
        return self.count

def worker(counter):
    counter.increment()

# Test that demonstrates the bug:
counter = SharedCounter()
threads = []

for i in range(5):
    t = threading.Thread(target=worker, args=(counter,))
    threads.append(t)
    t.start()

# Bug 3: Not waiting for threads to complete
print(f"Final count: {counter.get_count()}")  # Should be 5000, but isn't

# Bug 4: No cleanup/join of threads
```

Requirements:
1. Fix all race conditions
2. Ensure thread-safe operations
3. Properly wait for thread completion
4. Add a reset() method
5. Write tests to verify the fixes work