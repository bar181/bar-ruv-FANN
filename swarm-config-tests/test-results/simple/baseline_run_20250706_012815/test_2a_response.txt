## Bug Analysis

I identified two critical bugs in the factorial function:

1. **Bug 1 (Line 9)**: `result = 0` - The initial value should be `1`, not `0`. When multiplying by 0, the result will always be 0.

2. **Bug 2 (Line 10)**: `range(1, n)` - This excludes `n` from the range. For factorial, we need to include `n`, so it should be `range(1, n+1)`.

## Fixed Code

```python
def factorial(n):
    """
    Calculate factorial of n (n!)
    
    Args:
        n: Non-negative integer
        
    Returns:
        The factorial of n, or error message for negative numbers
        
    Examples:
        factorial(5) = 5! = 5 × 4 × 3 × 2 × 1 = 120
        factorial(0) = 1 (by definition)
    """
    if n < 0:
        return "Error: Negative number"
    
    result = 1  # Fixed: Changed from 0 to 1
    for i in range(1, n + 1):  # Fixed: Changed n to n+1 to include n
        result *= i
    
    return result


# Original test cases (now passing)
assert factorial(0) == 1  # Special case: 0! = 1
assert factorial(5) == 120  # 5! = 5 × 4 × 3 × 2 × 1 = 120
assert factorial(1) == 1  # 1! = 1

# Additional test cases
assert factorial(3) == 6  # 3! = 3 × 2 × 1 = 6
assert factorial(10) == 3628800  # 10! = 3,628,800
assert factorial(-5) == "Error: Negative number"  # Negative input handling

# Edge case tests
assert factorial(2) == 2  # Small positive number
assert factorial(20) == 2432902008176640000  # Large factorial

print("All tests passed!")
```

## Explanation of Fixes

1. **Initial value fix**: Changed `result = 0` to `result = 1`. This is crucial because:
   - Factorial is a product operation (multiplication)
   - The identity element for multiplication is 1, not 0
   - Any number multiplied by 0 equals 0, which caused all results to be 0

2. **Range fix**: Changed `range(1, n)` to `range(1, n+1)`. This is important because:
   - Python's `range(start, stop)` excludes the stop value
   - To calculate n!, we need to multiply all numbers from 1 to n inclusive
   - The original code was calculating (n-1)! when n > 0

3. **Special case handling**: The fixed code correctly handles:
   - `factorial(0) = 1` (by mathematical definition)
   - `factorial(1) = 1` (the loop runs once with i=1)
   - Negative numbers return an error message

The function now correctly calculates factorials for all non-negative integers.